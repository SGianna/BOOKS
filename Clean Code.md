
# Clean Code 
## 노개북 TIL (Today I Learned)
---

## 목차
1. [추천사 & 들어가면서](#-추천사-&-들어가면서)
2. [1장. 깨끗한 코드](#-1장-깨끗한-코드)
3. [2장. 의미있는 이름](#-2장-의미있는-이름)
4. [3장. 함수](##-3장.-함수)
5. [4장. 주석](##-4장.-주석)
6. [5장. 형식 맞추기](##-5장.-형식-맞추기)
7. [6장. 객체와 자료 구조](##-6장.-객체와-자료-구조)
8. [7장. 오류처리](##-7징.-오류처리)
9. [9장. 단위테스트](##-9장.-단위테스트)
## 부록
 - [Mission 1. 최애 TIL](#Mission-1.-최애-TIL)
<br/>

## 추천사 & 들어가면서
### 책에서 기억하고 싶은 책 문구
 - 사소한 곳에서 발휘하는 정직은 사소하지 않다. 
 - 소프트웨어는 80% 이상이 소위 "유지보수"이다.
 - 작은 것에도 충실한 사람이 큰 것에도 충실하다.
 - 제조업이란 메타포에서 재작업은 비용을 뜻하지만 소프트웨어 설계에서 재작업은 가치를 가져온다.

### 나의 생각
사탕 상자 뚜껑에 적힌 격언에서 내가 행했던 세세함의 행동에 대한 위로를 받았다. 
개발 속도가 느리고, 사소한것에 집중하는 모습을 단점으로 치부했던 나에게 조금의 안도를 주는 글이었다. 
그저 "유명한 책이다"라고만 알고있었던 책의 첫 문단을 읽어내려가면서 앞으로의 책 내용이 걱정되면서도 기대된다. 
마지막 페이지를 넘길 때 즈음엔 내가 어떤 결론에 도달해 있을 지 궁금해진다.

### 새롭게 알게된 내용
1. [애자일](https://www.youtube.com/playlist?list=PL9mhQYIlKEhf3JxWcaim5anL0_pVFRsZT)
   - 짧은 주기를 가지고 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법
2. 스크럼(Scrum)
   - 애자일 개발 방식 중 하나
   - 특정 개발 언어나 방법론에 의존적이지 않고, 일반적인 프로젝트 관리에도 사용가능한 프로세스 프레임워크
   - 작은 목표를 짧은 주기로 개발(전달)하는 관리 프레임 워크
3. [린(lean)](https://needjarvis.tistory.com/323) 
   - "낭비"에 포커스를 두고 프로젝트 수행 시 발생하는 모든 낭비를 제거하는 기법

<br/>

## 1장. 깨끗한 코드
### 책에서 기억하고 싶은 책 문구
 - 태도 : 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.
 - 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 애써봤자 소용이 없다.
 - "중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기. 내게는 이 세가지가 깨끗한 코드를 만드는 비결이다.", Ron Jeffries

### 나의 생각
머리를 한 대 얻어맞은 기분이다. 개발을 하면서 강박처럼 지저분하지 않는 코드, 모듈화가 잘 된 코드를 작성하려고 노력했다고 생각했다. 
하지만 설계부터 고심해서 완성한 코드는 항상 만족스럽지 않았다. 여러번의 수정을 거쳐도 마찬가지였다.
지금 생각해보면 나는 깨끗한 코드가 무엇인지 어떻게 작성하는지 모르는 상태였던 것이다.
 
### 새롭게 알게된 내용
1. 보이스카우트 규칙
   - 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라. 
   - 로버트 스테펜슨 스미스 바덴-파웰(Robert Stephenson Smyth Baden-Powell)이 스카우트에게 남긴 작별인사에서 나왔다. "처음 왔을 때보다 더 나은 세상을 만들고 떠나려 노력하라."
<br/>

## 2장. 의미있는 이름
### 책에서 기억하고 싶은 책 문구
 - 의도를 분명히 밝혀라 : 문제는 코드의 단순성이 아니라 코드의 함축성이다. 다시 말해, 코드의 맥락이 코드 자체에 명시적으로 드러나지 않는다. (p.23)
 - 검색하기 쉬운 이름을 사용하라 : 이름 길이는 범위 크기에 비례해야한다. (p.28) 
 - 한 개념에 한 단어를 사용하라 : 추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. (p.33)
 - 말장난을 하지 마라 
	> 이 메서드를 add라 불러도 괜찮을까? 
	> add라는 메서드가 많으므로 일관성을 지키려면 add라 불러야 하지 않을까? 
	> 하지만 새 메서드는 기존 add메서드와 맥락이 다르다. 새 메서드를 add라 부른다면 이는 말장난이다. (p.34)
 - 의미 있는 맥락을 추가하라 
	> 스스로 의미가 분명한 이름이 없지 않다. 하지만 대다수 이름은 그렇지 못하다. 
	> 그래서 클래스, 함수, 이름 공간에 넣어 맥락을 부여한다. 
	> 모든 방법이 실패하면 마지막 수단으로 접두어를 붙인다. (p.35)
 - 다른 사람이 짠 코드를 손본다면 리팩터링 도구를 사용해 문제 해결 목적으로 이름을 개선하라. (p.38)

### 나의 생각
프로그래밍을 시작하면서 처음 접하는 난관이자, 끝까지 고심하게되는 부분인 이름짓기.
이전 프로젝트를 다시 돌아보게된다. 일관되지 않은 단어 선택으로 혼자 고심하고 여러 수정안을 내놨었다.
이번 챕터를 읽으면서 가장 찔렸던 부분은 좋은 이름을 선택하는 능력은 기술, 관리 등의 문제가 아니라 교육 문제라는 것.
좋은 코드를 보면서 공부하는 시간이 많이 필요하다는 것을 다시금 느낀다. 

### 궁금한 내용
1. 문제 영역에서 가져온 이름을 사용하라
   - 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야한다. 

</br>

## 3장. 함수
### 책에서 기억하고 싶은 책 문구
- 한 함수내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부 사항인지 구분하기 어려운 탓이다. (p.46)
- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. (p.46)
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. (p.49)
- 출력 인수는 입력 인수보다 이해하기 어렵다. 
  흔히 우리는 함수에다 인수로 입력을 넘기고 반환 값으로 출력으 받는다는 개념에 익숙하다. 대개 함수에서 인수로 결과를 받으리라 기대하지 않는다. (p.51)
- 함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다. (p.51) 
	> 인수에 질문을 던지는 경우다. boolen fileExist("MyFile")이 좋은 예다. 
	> 다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen("MyFile")은 String 형의 파일 이름을 InputStream으로 변환한다. 
	> 다소 드물게 사용하지만 그래도 아주 유용한 단항 함수 형식이 이벤트다. passwordAttemptFailedNtimes(int attempts)가 좋은 예다. 
- 이항함수가 적절한 경우도 있다. Point p = new Point(0,0)가 좋은 예다. 인수 2개는 한 값을 표현하는 두 요소이다. 두 요소에는 자연적인 순서도 있다. (p.52) 
- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다. 예를 들어 write(name)은 누구나 곧바로 이해한다. (p.54)
- 함수 이름에 인수 이름을 넣는다. assertEquals보다 assertEqualsActual(expected,actual)이 더 좋다. 그러면 인수 순서를 기억할 필요가 없어진다.(p.54) 

### 나의 생각
올해 첫 개발 책으로 클린 코드를 선택해서 참 다행이라는 생각이 문득 들었다. 이번 챕터를 읽어내려가면서 혼자 끙끙 앓았던 고민들이 해결되는 느낌이었다. 
	_"처음부터 완벽히 짜야하는가? 구조를 계속 바꾸는 것은 옳지 않은가? 
	함수를 수행하고나서 성공여부를 리턴하는 방식이 꼭 필요한 것인가?
	함수는 어느 깊이까지 구현하는 것이 맞는가?"_

머릿속에 명쾌한 해답 없이 떠돌던 질문들이 짝을 이루고 자리를 찾아갔다. 
그동안 구글링을 하거나 팀원들의 코드를 보면서 혼자 체계를 잡아보려고 아둥바둥하다가 눈 앞에 놓인 문제를 해결하느라 흐지부지 지나가던 일이 많았었다. 
이렇게 나만의 시간을 가지면서 이론을 다시 정립하는 활동을 하게되어 기쁘다. 

- 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. </br>

내가 놓치고 있었던 부분이 무엇인지 확실히 깨닫게되는 말이었다. 
함수 내에서 어떻게 풀어써야 다른 사람이 나의 코드를 이해할 수 있을지에 대한 고민이 많았는데, 얼마나 구체적으로 기술하냐가 중요한 것이 아니었다. 
의도된 기능 이외의 단계들은 적절히 추상화하여 가려주어야 읽는 사람 입장에서는 더 이해하기 쉬운 것이었다!

- set 함수의 리턴 값 --> 명령과 조회를 같이하는 함수
- 예외를 위한 열거형 변수, 의존성 자석
- 출력 인수 사용 </br>

마지막으로 수행했던 프로젝트에서 내가 다른 코드를 리뷰하면서 배우고 구현했던 함수들이 떠올랐다. 
C 언어를 사용하여 개발을 하면서 물론 어쩔 수 없이 사용했던 방식도 있지만 책을 읽고 나서 그것이 얼마나 비효율적인 코드였으며,
어떻게 더 나은 방식을 구현할 수 있는 지 다시 생각해보게 되었다.  

- 한번에 짜내는 사람은 없다. 

처음부터 완벽한 코드 구조를 짜내려가는 사람은 없다. 내게 가장 필요한 말이었다. 
개발 건을 맡고 진행하면서 구조를 여러번 바꾸었는데, 실력이 부족해서 한번에 구조를 잡지 못하는 것이라 생각했다. 
물론 실력이 쌓이면 시행착오를 줄일 수 있지만, 이 과정 자체가 누구나 필요한 것이고 누구나 거쳐가는 것이라는 확신이 생기니까 자괴감에서 조금 벗어날 수 있었다.

### 궁금한 내용
1. FitNesse : 오픈소스테스트 도구
2. JUnit : 웹 기반 테스트 프레임 워크
3. TO문단 : LOGO언어에서 사용하는 키워드 'TO'는 루비나 파이썬에서 사용하는 'def'와 똑같다. LOGO에서 모든 함수는 키워드 'TO'로 시작한다. 
4. SRP(Single Responsibility Principle), OCP (Open Closed Principle)
5. 추상화 팩토리 
6. [도메인 특화 언어](https://www.jetbrains.com/ko-kr/mps/concepts/domain-specific-languages/) (DSL,Domain-Specific Languages) <-> 범용 언어(GPL,General-purpose programming language)
	- 관련 특정 분야에 최적화된 프로그래밍 언어
 	- 대부분의 경우, DSL은 소프트웨어 전문가가 아닌, 해당 DSL의 대상 분야에 능통한 비 프로그래머가 사용하도록 제작됨

</br>

## 4장. 주석
### 책에서 기억하고 싶은 책 문구
> 나쁜 코드에 주석을 달지 마라. 새로 짜라.
> 브라이언 W.커니핸, P.J.플라우거
#### 좋은 주석
- 법적인 주석 : 저작권 정보와 소유권 정보는 필요하다. 
- 정보를 제공하는 주석 : 기본적인 정보를 주석으로 제공, 가능하다면 함수 이름에 정보를 담는 편이 더 좋다. 
- 의도를 설명하는 주석 
- 의미를 명료하게 밝히는 주석 : 인수나 반환 값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.
- 결과를 경고하는 주석
- TODO 주석 : 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기술한다. 
- 중요성을 강조하는 주석 

#### 나쁜주석
- 이해가 안 되어 다른 모듈까지 뒤져야 하는 주석은 독자와 제대로 소통하지 못하는 주석이다. 그런 주석은 바이트만 낭비할 뿐이다. 
- 같은 이야기를 중복하는 주석 : 실제로 코드보다 부적황해 독자가 함수를 대충 이해하고 넘어가게 만든다. 
- 의무적으로 다는 주석 : 모든 함수에 javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지 없다. 
- 이력을 기록하는 주석 : 예전에는 모든 모듈 첫머리에 변경 이력을 기록하고 관리하는 관례가 바람직했다. 당시에는 소스코드 관리 시스템이 없었으니까. 
- 있으나 마나 한 주석 
- 무서운 잡음 : 잘라서 붙여넣기 오류가 보이는가? 주석을 작성한 저자가 주의를 기울이지 않았다면 독자가 여기서 무슨 이익을 얻겠는가?
- 함수나 변수로 표현할 수 있다면 주석을 달지 마라 
- 위치를 표시하는 주석 : ////////////////////////action////////////////////////  --> 반드시 필요할 때만, 아주 드물게 사용하는 편이 좋다. 
- 닫는 괄호에 다는 주석 : 작고 캡슐화된 함수에는 잡음일 뿐이다. 그러므로 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.
- 공로를 돌리거나 저자를 표시하는 주석 : 저자 이름으로 코드를 오염시킬 필요가 없다. 
- 주석으로 처리한 코드 
- HTML 주석
- 전역 정보 : 바로 아래 함수가 아니라 시스템 어딘가에 있는 다른 함수를 설명한다는 말이다. 코드가 변해도 주석이 변하리라는 보장은 전혀 없다. 
- 너무 많은 정보
- 모호한 관계 : 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야한다. 
- 함수 헤더 
- 비공개 코드에서 Javadocs
  
### 나의 생각
주석에 관해 알고있었던 정보들은 대부분 엉터리였다. 그래서 나쁜 주석의 리스트를 보면서 찔리는 부분이 많았다. 
옛날에 짜여진 코드를 보면서 배우고 따라했던 부분도 있었는데, 현재는 환영 받지 못하는 방법이라는 것을 깨닫게되었다. 
위치를 표시하는 주석을 열심히 달면서 주석을 잘 적었다고 생각했는데, 오히려 지저분한 코드를 만들고 있었다.
(그외에도 이력 기록.. 저자표시.. 닫는 괄호에 다는 주석 등)

프로젝트를 하면서 가장 많이 했던 말이<br/>
" 왜 주석을 안달까.." <br/>
" 왜 주석이 틀릴까.." <br/>
였다. 내가 했어야하는 말은 그게 아니라 "왜 클린 코드가 아닐까" 였다.

> 아래 모듈이 매력적인 이유는 우리들 상당수가 이런 코드를 보면서 '주석을 잘 달았다'고 생각하던 시절이 있었기 때문이다. 
> 이제는 엉성한 코드로 여겨진다. <br/>

기술이 발전하면서 주석을 "잘" 다는 방법도 계속해서 변화해왔다는 사실을 알게되었다. 
앞으로도 이번 한번에 멈추지 않고 클린 코드 작성 방법을 꾸준히 업데이트 해야겠다.
</br>

## 5장. 형식 맞추기
### 책에서 기억하고 싶은 책 문구

  
### 나의 생각


### 궁금한 내용
</br>

## 6장. 객체와 자료구조

### 책에서 기억하고 싶은 책 문구
#### 자료 추상화 
- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다.
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
#### 자료/객체 비대칭
- 객체는 추상화 뒤로 자료를 숨김 채 자료를 다루는 함수만 공개한다. 
- 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 
- 분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료구조와 절차적인 코드가 가장 적합한 상황도 있다. 
#### 디미터 법칙
- 객체는 조회 함수 (get function)으로 내부 구조를 공개하면 안 된다는 의미다. 
- 객체에서 허용된 메서드가 반환하는 객체의 메서드를 호출하면 안된다. 
- 다시 말해, 낯선 사람은 경계하고 친구랑만 놀라는 의미다. 
#### 자료 전달 객체 
- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라 한다. 
- 좀 더 일반적인 형태는 빈(bean)구조다. 빈은 비공개 변수를 조회/설정 함수로 조작한다. 

### 나의 생각
오늘 챕터에서 '자료/객체 비대칭' 에 관한 내용이 특히 인상적이었다.
C 언어의 절차지향 프로그래밍과 자바의 객체 지향 프로그래밍이 코드를 짤때 바라보는 시각의 차이를 느끼게되었다. 
C 언어를 직접적으로 언급하지는 않았지만, 자바의 자료 구조와 절차적인 프로그래밍 작성 방식이 바로 C 언어의 프로그래밍 방식이지 않을까.

> (어떤) 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 
> 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 

책 내용을 직접 경험한 적이 있었다. 자바를 잠깐 배울 때, 다형메서드를 추가하면서 모든 클래스를 수정하는게 번거롭게 느껴지고
차라리 C 언어가 낫다고 생각했었다. 그렇게 단순히 생각하고 지나갔었는데 그게 바로 코드 작성 방식의 차이였다. 
다시 객체지향 프로그래밍을 하게된다면 이전보다 더 이해하면서 코드를 볼 수 있을 것 같다. 

### 궁금한 내용
1. [휴리스틱(heuristic)]([https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=firerisk&logNo=220697783341)
- 알고리즘의 반대 개념
- 알고리즘이 확립되지 않았을 때 사용되는 문제 해결의 한 방법
- 논리적 추론보다 경험적, 직관적 사고 체계로 빠르게 의사결정하는 능력

2. 활성 레코드
- 자료 전달 객체(Data Transfer Object,DTO)의 특수한 형태
- 활성 레코드는 자료구조로 취급
</br>

## 7장 오류 처리
### 책에서 기억하고 싶은 책 문구
- 뭔가 잘못될 가능성은 늘 존재한다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있다. 
- 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 
#### 오류 코드보다 예외를 사용하라.
#### Try-Catch-Finally 문부터 작성하라
#### 미확인(unchecked)예외를 사용하라
- 확인된 예외는 OCP(Open Closed Principle)을 위반한다. 
- 즉, 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다는 말이다. 
- 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다. 
#### 예외에 의미를 제공하라
#### 호출자를 고려해 예외 클래스를 정의하라
- 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야한다. 
- 외부 API를 사용할 때는 감싸기 (Wrapper) 기법이 최선이다.
	- 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.
	- 또한 감싸기(wrapper) 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다. 
	- 마지막 장점으로 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다. 
#### 정상 흐름을 정의하라
#### null을 반환하지 마라
- null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다.
- 사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 
#### null을 전달하지 마라
- 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다. 
- NullPoiterException이 발생한 경우
	- 새로운 예외 유형을 만들어 던지는 방법
	- assert문을 사용하는 방법

### 나의 생각
이번 챕터에서 얘기하고자 하는 클린 코드는 이 짧은 표현으로 설명이 가능하다. 

> 비즈니스 논리와 오류 처리가 잘 분리된 코드 (p.137)

이전 프로젝트를 떠올려보면 예외 처리와 논리들이 뒤엉켜있는 경우가 많았다. 
물론 C언어에서는 따로 예외처리 기능이 없어서 완벽히 구분하는 것은 어렵다. 하지만 깔끔하게 처리 하는 방법에 대해 다시 생각해보게 되었다. 
직전 프로젝트에서 외부 라이브러리를 가져다 쓰면서 내부 에러 로그를 파악하고 처리하느라 애를 먹었는데, 간단히 wrapper 기법을 사용했다면 좀 더 깔끔한 코드 작성이 가능했을 것 같다. 

당시 같이 작업했던 팀원의 코드 방식을 이제야 이해하게 되었다. 
그 분은 에러 값을 함수의 인수로 받아 모든 예외 로그를 찍었었는데, C 언어에서 예외 처리를 깔끔하게 하기 위한 나름의 방법이었다. 

학업과 실무가 나뉘어지는 부분 중 하나가 바로 이 예외 처리 부분이 아닐까 싶다. 학업에서는 단순히 기능을 구현하면서 기술을 익혀가는 반면,
실무에서는 해당 프로젝트가 end-user 손에서 사용되는 동안 어떠한 상황에서도 정상 동작할 수 있도록 안정화 하는 것이 매우 중요하다. 
하지만 이 부분은 오로지 실무에서 직접 부딪히면서 경험을 해야해서 부담감이 상당했다. 
이번 챕터의 내용이 대부분 자바의 예외처리 기능을 효과적으로 사용하는 방법이라 방법론적인 면에서는 놓치는 부분이 많았지만,
다른 언어에서 처리하는 방식을 보면서 C 언어에서 어떻게 구현하면 좋을 지 생각해보는 좋은 계기가 되었다. 

### 궁금한 내용
1. [자바에서의 예외처리](https://ko.myservername.com/java-exceptions-exception-handling-with-examples)
	- 자바에서의 예외 처리는 응용 프로그램의 정상적인 흐름을 유지하는 메커니즘이다. 
2. [특수 사례 패턴(Special Case Pattern)](https://java-design-patterns.com/patterns/special-case/)
	- Define some special cases, and encapsulates them into subclasses that provide different special behaviors.
3. [캡슐화, 은닉화](https://dokdogalmaegi.tistory.com/48)
	- 은닉화는 속성을, 캡슐화는 기능(메서드)를 담당해 중요한 정보를 은닉한다. 
4. [오브젝트 C](https://en.wikipedia.org/wiki/Objective-C)
	- C 프로그래밍 언어에 스몰토크 스타일의 메시지 구문을 추가한 객체 지향 언어이다. 
	- 현재, 이 언어는 애플 운영체제인 OS X와 iOS에서 사용되고 있다. 
</br>

## 9장 단위 테스트
### 책에서 기억하고 싶은 책 문구
#### TDD 법칙 세가지
- 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 
- 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 
#### 깨끗한 테스트 코드 유지하기
- 테스트 코드는 실제 코드 못지 않게 중요하다. 
#### 테스트는 유연성, 유지보수성, 재사용성을 제공한다
- 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠이다. 
#### 깨끗한 테스트 코드
- 깨끗한 테스트 코드를 만들려면? 세 가지가 필요하다. 가독성, 가독성, 가독성
#### 도메인 특화된 테스트 언어
- 흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현
- 이렇게 구현한 한수와 유틸리티는 테스트 코드에서 사용하는 특수 API가 된다. 
#### 이중표준
- 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다. 
- 대개 메모리나 CPU 효율과 관련 있는 경우다. 
- 코드의 깨끗함과는 철저히 무관하다. 
#### 테스트 당 assert하나
#### 테스트 당 개념 하나
- 가장 좋은 규칙은 "개념 당 assert문 수를 최소로 줄여라"와 "테스트 함수 하나는 개념 하나만 테스트하라"라 하겠다. 
#### F.I.R.S.T
- Fast : 테스트는 빨라야한다. 
- Independent : 각 테스트는 서로 의존하면 안된다. 
- Repeatable : 테스트는 어떤 환경에서도 반복 가능해야한다. 
- Self-Validating : 테스트는 bool 값으로 결과를 내야한다. 
- Timely : 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 

### 나의 생각
임베디드 시스템을 개발하면서 제일 고민을 많이했던 부분이 바로 '테스트'다. 
시스템 특성 상 테스트를 위해서는 타겟 보드에 프로그램을 넣고 실행하는 느리고 긴 인내의 시간을 견뎌야하기 때문이다. 
테스트를 위해서는 일단 타겟 보드를 준비해야한다. 부품 수급일 보다 개발 일정이 먼저가 되는 경우는 정말 난감하다. 
어찌저찌 타겟 보드를 만들어 이제 프로그램을 실행했을 때, 동작이 안된다면 이게 보드문제인지 코드문제인지 확인해야한다.
특히 하드웨어팀과 펌웨어 개발팀이 나누어진다면 이는 타팀과의 협의까지 필요하게된다. 모두가 인내의 시간들이다.
이러한 특징때문에 나는 타겟보드 없이, 코드를 테스트할 수 있는 방법에 대해 고민이 많았다.

그리고 TDD를 알게 되었다. 강의 제목이 '임베디드 시스템 테스트 방법' 이었고 딱 원하던 주제여서 선택을 했는데, 그 안에 내용은 정말 새로웠다. 
CMOCK이라는 라이브러리를 사용하여 하드웨어 핸들링 부분을 처리하고 시뮬레이션을 돌릴 수 있는 방법에 대해 설명했다. 
그리고 TDD 법칙의 기본인 테스트 후 실제 코드 방법 방식에 대해 배우게되었다. 
사실 이 TDD 법칙을 보고 나서 이건 실무에 적용시키지 못할것이라고 판단했는데, 
테스트하고 실제 코드를 작성할 때 까지 정말 시간이 많이 걸리고, 프로젝트 폴더를 함께 관리하는 팀에서 모두가 이러한 방식을 따르지 않는다면,
수행할 수 없는 방식이라고 생각했기 때문이다. 

그런데 클린코드에서 또다시 TDD를 보게되었다. TDD를 개인적으로 각 개발자가 개인적으로 (팀에서 사용하지 않더라고) 사용할 수 있는지 
궁금해지기 시작했다. 이 방식을 나도 앞으로 사용할 수 있을까?  

### 궁금한 내용
1. TDD 방식을 실무에서 사용하는 경우가 많은지? 
 - 친절한 답변 :)
	- 팀에 전체적인 동의가 없으면 어렵습니다. 그래서 도입할 때 제일 먼저 생각해야 하는 건 얼마나 쉽게 테스트를 추가할 수 있는지입니다. 그래야 다른 개발자들을 설득할 수 있어서요
2. 팀 단위가 아닌 개인적으로 자신의 코드를 테스트할 때 TDD 사용 가능?
 - 친절한 답변들 :)
 	- 네, 사용 가능합니다. Java 사용하신다면 JUnit으로 그 외 React나 Vue.js, JavaScript 사용하신다면 Jest 같은 거 사용해서 테스트 코드 작성하셔서 사용하시면 될 것 같습니다.
 	- 프론트엔드 테스트 도구인 cypress도 사용합니다!
</br>
## Mission 1. 최애 TIL
1. [robinyeon님의 Github](https://github.com/robinyeon/TIL/)
 - 선정 이유 : Github에 TIL 작성을 생각하면서 형식을 잡는 데 많은 도움을 받을 수 있었다. 
2. [inkyu0103님의 velog](https://velog.io/@inkyu0103/Books-Clean-Code-TIL-2)
 - 선정 이유 : 읽은 소감을 정리하신 부분이 인상 깊었다. 
3. [catsbi님의 oopy](https://catsbi.oopy.io/e538c4d1-8620-4c33-b040-59c6bba56a44)
 - 선정 이유 : 클린 코드 요약본을 보는 느낌이였다. 각 챕터마다 이해하고 정리하는 데 많은 시간과 노력을 기울이신게 느껴졌다. 
 
#노마드코더 #북클럽 #노개북

"이 글은 [Robinyeon 님의 클린 코드](https://github.com/robinyeon/TIL/) TIL 작성 형식을 참고하였습니다."
