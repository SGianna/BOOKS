
# The Pragmatic Programmer 
## 노개북 TIL (Today I Learned)
---

## 목차
1. [추천사 & 서문](#추천사_&_서문)
2. [1장 실용주의 철학](##_1장_실용주의_철학)
3. [2장 실용주의 접근법](##_2장_실용주의_접근법)
4. [3장 기본 도구](##_3장_기본_도구)

## 부록
[최애_TIL](##_최애_TIL)
<br/>

## 추천사 & 서문 
### 책에서 기억하고 싶은 책 문구
> 쉬운 정답은 없다. 도구든, 언어든, 운영 체제든 최고의 해결 방안 같은 것은 없다. 오직 특정한 환경 조건들마다 가장 적절한 시스템들이 있을 뿐이다. 
> 바로 이것이 실용주의가 필요한 이유다. 
> 어떤 특정 기술에 메이면 안 된다. 개별 상황마다 그 상황에서 좋은 해결 방안을 고를 수 있도록 충붐한 배경 지식과 경험을 쌓아야한다. 
<br/>

## 1장 실용주의 철학
### 책에서 기억하고 싶은 책 문구
- '깨진 창문'을 고치지 않은 채로 내버려 두지 말라. 나쁜 설계, 잘못된 결정, 혹은 형편 없는 코드 등이 모두 깨진 창문이다. 발결하자마자 바로 고쳐라 (p.9)
- 어떤 위기가 찾아왔다고 해서 부가적인 피해를 일으키지 말라. 깨진 창문은 하나로 충분하다. (p.10)
- 큰 그림에 늘 주의를 기울여라. 당장 하고 있는 일에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는 지 늘 살펴보라. (p.14)
- 우리는 종종 뭔가 나이지게 하려다가 괜찮은 것마저 망친다. - 셰익스피어, <리어왕> 1막 4장 (p.15)
- 여러분이 만드는 시스템의 범위와 품질은 해당 시스템의 요구 사항 중 하나로 논의되어야 한다.
- 오늘의 훌륭한 소프트웨어는 많은 경우 환상에 불과한 내일의 완벽한 소프트웨어보다 낫다. 
- 완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라. 
- 지식은 기한이 있는 자산이고 인기있는 기술도 마찬가지다. (p.27)
- 실용주의 프로그래머는 문서화를 전체 개발 프로세스의 필요 불가결한 부분으로 받아들인다. 
 
### 나의 생각
1장은 개발자로써의 태도나 성장을 위한 방향에 대해 체계적으로 배울 수 있었다. 
요즘 다시 개발자의 진로를 생각하면서 어떤 공부를 해야 부족한 지식을 채울 수 있을 지 고민했는데
이 책을 읽다보면 그 방향을 찾을 수 있을 것 같다. 
한 챕터에 담겨있는 내용이 워낙 많아서 책 내용을 상기하고 익히기까지 여러번 다시 책을 펼쳐봐야할 것 같다. 

각 장마다 topic과 tip을 기재하고 이번 장과 관련된 항목을 표기하며 생각해볼 내용에 대해 질문을 던진다. 
책 카테고리의 대한 재정의가 필요해 보인다. 확실히 이건 기술적인 책으로만 분리하기엔 어려움이 있어보인다. 

### 새롭게 알게된 내용
1. 기능 블로트 현상(feature bloat)
 - 소프트웨어가 쓰는 기능에 비해 많은 기능을 가지고 있는 데, 기능이 많은 만큼 버그나 보안 취약점이 생길 가능성도 높은 것을 말한다. 
2. 읽으면 도움이 될 책들
 - <함께 자라기> : 배우는 방법 자체에 대해 배우는 책
 - 매우 상세한 구현과 코딩을 하고 있다면 '설계와 아키텍처'에 대한 책을 읽어라
 - 고차원의 설계를 하고 있다면 코딩 테크닉을 다루는 책을 읽어라
 - <맨먼스 미신>, <피플웨어> : 팀 내 의사소통에 관한 내용
 - <파충류의 뇌 : 일터에서 만나는 곤란한 사람 상대하기> 
<br/>

## 2장 실용주의 접근법
### 책에서 기억하고 싶은 책 문구
#### 좋은 설계의 핵심
 - ETC원칙 (Easy to Change)은 규칙이 아니라 가치. 가치는 여러분이 결정을 내리게 도움을 주는 것이다. 
 - 엔지니어링 일지에 현재 상황과 여러분의 선택, 그리고 변경 사항에 대한 추측을 정리해 둬라. 그리고 소스코드에 이에대한 표시를 남겨 둬라.
#### DRY: 중복의 해악 
> 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다. 
 - 우리의 이해는 날마다 바뀐다.
 - 유지 보수는 별개의 활동이 아니며 전체 개발 과정의 일상적인 부분이다.
 - 문제는 명세와 프로세스, 개발하는 프로그램 안에 지식을 중복해서 넣기 쉽다는 것이다. 그렇게 된다면 애플리케이션이 출시되기 한참 전부터 유지 보수의 악몽이 시작될 것이다. 
 - DRY는 지식의 중복, 의도의 중복에 대한 것이다. 코드를 바꾸고 문서도 바꾸는가? 그렇다면 여러분의 코드는 DRY 하지 않다.
 - 모든 코드 중복이 지식의 중복은 아니다.
#### 직교성
 - 설계 - 툴킷과 라이브러리 - 코딩 - 테스트 - 문서화
 - 컴퓨터 과학에서 이 용어는 일종의 독립성이나, 결합도 줄이기를 의미한다. 
 - 직교적이라는 것을 설명할 때 '모듈식','컴포넌트 기반','계층'같은 다른 용어를 사용하기도 하지만 말이다.
 - 객체의 상태를 바꿀 필요가 있다면 여러분을 위해 객체가 직접 상태를 바꾸게 하라. (p.61)
 - 중복 코드는 구조에 문제가 있다는 징후다. 
 - 단위 테스트를 빌드하고 실행하기 위해 어떤 작업이 필요한가? 나머지 시스템 중 상당 부분을 불러와야 하지는 않는가? 만약 그렇다면 모듈과 나머지 시스템 사이의 결합도를 충분히 줄이지 못했다는 뜻이다. 
 - 테스트를 마친 뒤 코드를 병합할 때 버그 수정에 대한 태그를 붙여라. 이렇게 하면 버그 수정마다 수정한 소스 파일 개수를 수집하여 그 경향을 분석한 월 단위 리포트를 만들 수 있을 것이다. 
 - 놀랍게도 직교성은 문서에도 적용할 수 있다. 내용과 표현이라는 두 개의 축이 있다. 
#### 가역성
 - 많은 사람들이 코드를 유연하게 유지하려고 노력한다. 그런데 아키텍처, 배포, 외부 제품과의 통합 영역을 유연하게 유지하는 데에도 관심을 기울일 필요가 있다. 
 - 외부의 API를 여러분이 만든 추상화 계층 뒤로 숨겨라.
#### 예광탄
 - 시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라. 
 - 예광탄 코드도 다른 제품 코드와 마찬가지로 오류 검사, 올바른 구조, 문서화, 자체 검사를 갖추어야 한다.
 - 장점 
   - 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다. 
   - 개발자가 들어가서 일할 수 있는 구조를 얻는다
   - 통합 작업을 수행할 기반이 생긴다. 
   - 보여줄 것이 생긴다.
   - 진행 상황에 대해 더 정확하게 감을 잡을 수 있다. 
 - 프로토타입은 나중에 버리는 코드를 만든다. 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격 중 일부가 된다. 
#### 프로토타입과 포스트잇
 - 소프트웨어 프로토타입도 같은 이유에서 같은 방식으로 만든다. 즉, 위험 요소를 분석하고 노출시킨 후, 이를 매우 저렴한 비용으로 바로잡을 기회를 얻는 것이다. 자동차와 마찬가지로 각 프로토타입을 만들 때 마다 프로젝트의 특정 측면에 중점을 둘 수 있다. 
 - 하지만 세부 사항을 포기할 수 없는 환경에 처해 있다면 진짜로 프로토타입을 만들고 있는 게 맞는지 자문해 보라. 아마도 이런 경우에는 예광탄 방식의 개발이 더 적절할 것이다. 
 - 프로토타이핑의 가치는 생산한 코드에 있는 것이 아니라 이를 통해 배우는 교훈에 있다. 
 - 프로토카입 코드에는 주석이나 문서가 많지 않아야 한다. 다만, 프로토타입을 사용해 본 결과를 문서로 많이 작성할 수 있다. 
#### 도메인 언어
 > 언어의 한계가 곧 자기 세계의 한계다. - 철학자 루트비히 비트겐슈타인(Ludwig Wittgenstein)
 - 거꾸로 문제 도메인의 언어가 어떤 프로그래밍 해결방안을 제안하기도 하는데, 우리 생각에는 이것이 프로그래밍 언어의 사고방식보다 더 중요하다. 
 - 여러분이 실행시키는 코드 안으로 들어간다. : 내부 도메인 언어
 - 별도의 코드가 이 언어를 읽어 들여서 사용할 수 있는 형태로 바꾼다. : 외부 언어
#### 추정
 - 얼마나 정확해야 충분히 정확한가? 
   - 질문자가 매우 높은 정확도의 답을 요구하는가, 아니면 단순히 큰 그림만을 요구하는가?
   - 추정에서 한 가지 재미있는 사실은 사용하는 단위가 결과의 해석에 차이를 가져온다는 것이다. 
   - 1 ~ 15일: 일 / 3 ~ 6주: 주 / 8 ~ 20주: 달 / 20주 이상: 추정치를 말하기 전에 다시 한번 생각해보라.
 - 자주 다른 사람의 경험을 바탕으로 성공적인 추정치를 낼 수 있을 것이다. 
 - 추정하기 전에 미리 어떤 조건이 있을지 생각하는 습관을 길러야 한다. 종종 여러분이 선택한 조건은 답변의 일부가 되기도 한다. 
 - 여러분이 계산한 추정치를 기록해 놓고, 나중에 이 값이 실제 결과에 얼마나 가까웠는지를 평가해 보면 정말 좋을 것이다. 
 
### 나의 생각
가치를 달성하기 위해 규칙을 만들어 실천한다. 

양자 역학의 슈뢰딩거 고양이 이야기로 비춰보면, 성공과 실패라는 결과도 결국은 둘다 정답이다. 하지만 어떠한 우주를 선택하는지는 나의 선택이다.
> 상자를 열 용기가 있는가?

### 새롭게 알게된 내용
1. 프로그래밍 패러다임 (객체 지향, 함수형, 반응형)
2. 컴포넌트 기반
3. 트랜잭션 지향 시스템
 - 엔터프라이즈 자바빈즈 시스템 (EJB)
4. 문서 데이터베이스(document database)
 - 데이터를 JSON 등의 형식을 사용하여 문서 단위로 저장하는 데이터 베이스, NoSQL 저장소의 일종이다.
 - MongoDB,Couchbase 등이 그것이다.
5. 스크립트 언어
6. 언어의 특징들
 - 정적 타입 대 동적 타입
 - 이른 바인딩 대 늦은 바인딩
 - 함수형 대 객체 지향
 - 상속 모델
 - 믹스인
 - 매크로
7. nginx(엔진 엑스)
 - 2021년 기준으로 아파치 웹서버 다음으로 많이 사용하는 웹서버
8. 파서 생성기, 파서 프레임워크
 - bison(바이슨)
 - ANTLR(앤틀러)
 - PEG 파서
 - 파이썬 기본 구현인 CPython이 3.9부터 PEG 파서를 사용한다. 
9. 도움이 될 책들
 - <Gof의 디자인패턴> 
  - 장식자 패턴 (decorator pattern)(p.61)
  - 싱글턴 패턴 (singleton pattern)(p.62)
  - 전략 패턴 (strategy pattern)(p.62)
<br/>

## 3장 기본 도구
### 책에서 기억하고 싶은 책 문구
 - 사용하는 도구로 다룰 수 없는 문제를 마주쳤다는 생각이 들면, 도움이 될 만한 다른 것이나 더 강력한 것을 찾아보아야 한다는 것을 명심하라.
#### 일반 텍스트의 힘
 - 실용주의 프로그래머로서 우리의 기본 재료는 나무나 쇠가 아니라 지식이다. 
 - 일반 텍스트는 인쇄 가능한 문자로 이루어지고, 정보를 전달하기에 적합한 형식을 갖추어야 한다. 
 - 모든 소프트웨어는 작성되자마자 레거시가 된다. 
#### 셸 가지고 놀기
 - 텍스트 파일을 다루는 프로그래머에겐 명령어 셸이 작업대다. 
 - 모든 작업을 GUI로만 하면 여러분이 가진 환경의 능력을 전부 이용할 수 없다. 
#### 파워 에디팅
 - 각각의 에디터에 유창해지도록 노력해야한다.
 - 어떤 것이 '유창'한 것인가? 이 과제들을 마우스나 트랙패드 없이 모두 수행할 수 있는가?
 	- 텍스트를 편집할 때 문자, 단어, 줄, 문단 단위로 커서를 이동하거나 내용을 선택하라.
 	- 코드를 편집할 때 반대쪽 괄호로 이동하거나, 함수, 모듈 등 다양한 문법 단위로 커서를 이동하라.
 	- 변경한 코드의 들여쓰기를 자동으로 맞춰라. 
 	- 여러 줄의 코드를 명령 하나로 주석 처리했다가 다시 주석을 해제하라. 
 	- 실행 취소를 여러 번 했다가 취소한 명령을 재실행 기능으로 다시 수행하라.
	- 에디터 창을 여러 구영으로 쪼개라. 그리고 각 구역 사이를 이동하라. 
	- 특정 줄 번호로 이동하라.
	- 여러 줄을 선택한 후 가나다순으로 정렬하라.
 	- 문자열로, 또 정규 표현식으로 검색하라. 이전에 검색했던 것을 다시 검색하라. 
	- 선택 영역이나 패턴 검색을 이용하여 일시적으로 여러 개의 커서를 만든 다음, 동시에 여러 곳의 텍스트를 편집하가.
 	- 현재 프로젝트의 컴파일 오류를 표시하라. 
	- 현재 프로젝트의 테스트를 실행하라. 
#### 버전 관리
 - 버전 관리 시스템은 일종의 거대한 '실행 취소' 키와 같다. 
 - 여러분이 작업하는 것이 소스 코드가 아닐지라도, 모든 것을 버전 관리 아래에 둬라. 각종 문서, 메모, makefile, 빌드와 릴리스 절차, 로그 파일을 정리하는 작은 셸 스크립트까지 모두 다.
 - 경험이 좀 더 쌓인 후에 여러분의 사용 방식을 검토하고 조정하는 것을 잊지 말라.
 - 이런 도구들을 꼭 사용해야 하는 것은 아니다. 하지만 결정을 내리려면 적어도 이것들이 무엇을 하는 것인지는 알아야 한다.
#### 디버깅
> 참으로 고통스러운 일입니다.
> 자신이 겪는 어려움을 보고는 알게 되죠.
> 다른 누구도 아닌 바로 자신이 문제를 만들었다는 걸.
> -소포클레스(Sophocles)<아이아스>
 - 겉으로 드러난 특정한 증상만 고치려고 하지 말고, 항상 문제의 근본 원인을 찾으려고 노력하라.
 - 버그를 살펴보기 전에 일단 작업 중인 코드가 경고 없이 깨끗하게 빌드되는지부터 확인하라. 
 - 인공적인 테스트 - 예컨대 프로그래머가 밑에서 위로 선을 그은 것 같은 테스트-는 애플리케이션을 충분히 테스트하지 못한다. 경계 조건과 실제 최종 사용자의 사용 패턴 모두를 철저히 테스트해야 한다. 
 - 트레이싱(tracing) 구문은 화면 혹은 파일에 출력하는 작은 진단용 메시지를 일컫는다. 트레이싱은 여러 프로세스가 동시에 작동하는 경우, 실시간 시스템, 이벤트 기반 애플리케이션 등, 시간 자체가 중요한 요소가 되는 시스템에서 이루 말할 수 없이 소중하다.
 - 로그 파일을 텍스트 처리 도구와 셸 명령어로 처리하면 문제를 쉽게 찾아낼 수 있다. 
 - 버그와 관련된 루틴이나 코드가 제대로 작동하는 걸 '안다'고 해서 대충 얼버무리고 지나치지 말라. 그것을 증명하라. "이 맥락" 안에서, "이 데이터"로, "이 경계 조건"하에서 증명하라.
 - 놀라운 버그를 마주쳤을 떄, 왜 이 문제가 더 일찍 발견되지 않았을까 생각해 봐야 한다. 버그를 미리 잡을 수 있도록 단위 테스트나 다른 테스트를 수정할 필요가 있는지 고민해 봐라.
 
### 나의 생각
이슈 트랙킹을 할 때 로그 파일을 열어 line by line 따라가면서 몇시간씩 보냈던 옛날이 떠올랐다. 
이 시간을 절약할 수 있는 방법이 규칙적이고 일관된 형식, 그리고 이를 찾아낼 수 있는 텍스트 처리 도구와 셸 명령어들이다. 

파이썬 공부가 어느정도 마무리가 된다면 다음으로 배우고 싶은 것이 확실해졌다. 
셸 프로그래밍을 해봐야겠다! 내 작업대를 만들어야겠다.

임베디드 시스템에서 사용하는 언어가 아니라는 이유로 다른 언어의 지식을 익히지 않은 행동이 내 성장 동력이 막고 있었다는 사실을 뼈저리게 깨닫게 되는 챕터였다.
업무에 직접적인 연관이 없더라도 업무 효율을 높일 수 있는 많은 기술들이 있다. 에디터를 fluency 하게 사용하는 것, 필요한 상황에 맞는 스트립트를 짜는 것 등 
내가 부족한 것이 무엇인지 앞으로 무엇을 해야하는지 방향이 보이기 시작했다.

### 새롭게 알게된 내용
 - YAML
 - JSON
 - 유닉스 철학
 	- 유닉스는 작고 예리한 각각의 도구가 한 가지 일만 잘하도록 만들자는 철학에 따라 설계된 것으로 유명하다. (p.109) 
 - 회귀 테스트 (regression test)
 	- 동일한 테스트를 반복적으로 수행함으로써 새로운 기능이 애플리케이션에 추가되었을 때 기존 기능이 여전히 제대로 작동하는지 검사하는 테스트다. 
	- 회귀 테스트에서 찾아낸 문제를 리그레션(regression)이라 부르기도 한다. 
 -훅(hook) 
</br>
## 최애 TIL
 - [aliyooncreative 님의 노션](https://aliyooncreative.notion.site/TIL-2022-03-19-76829557bc4f479c9ac39631a9e0ed82)
 - [corepen 님의 velog](https://velog.io/@corepen_?tag=%EB%85%B8%EA%B0%9C%EB%B6%81)
 - [pleed0215 님의 노션](https://pleed0215.notion.site/TIL-2022-03-20-4ca7872472914687a2f74b7f66b8e477)

#노마드코더 #북클럽 #노개북
